<jittershader name="fill-flat-quads">
	<description>Default Shader </description>
	<param name="pos" type="vec3" state="POSITION" />
	<param name="nor" type="vec3" state="NORMAL" />
	<param name="M" type="mat4" state="WORLD_MATRIX" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />
	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />

	<param name="ligPos" type="vec3" default="0. 1. 0." />
	<param name="ligDir" type="vec3" default="0. 0. 1." />
	<param name="ligWidth" type="float" default="1." />
	<param name="ligHeight" type="float" default="1." />
	<param name="twoSided" type="int" default="0" />
	<param name="ligColor" type="vec3" default="1. 1. 1. 1." />
	<language name="glsl" version="1.5">
		<bind param="pos" program="vp" />
		<bind param="nor" program="vp" />
		<bind param="M" program="vp" />
		<bind param="MVP" program="vp" />
		<bind param="eye" program="fp" />

		<bind param="ligPos" program="fp" />
		<bind param="ligDir" program="fp" />
		<bind param="ligWidth" program="fp" />
		<bind param="ligHeight" program="fp" />
		<bind param="twoSided" program="fp" />
		<bind param="ligColor" program="fp" />
		<program name="vp" type="vertex">
<![CDATA[
#version 330 core
uniform mat4 MVP, M;
in vec3 pos, nor;

out jit_PerVertex {
	smooth vec3 nor;
	smooth vec3 pos;
} jit_out;

void main() {	
	gl_Position = MVP * vec4(pos, 1.);	
	jit_out.nor = (M * vec4(nor, 0.)).xyz;
	jit_out.pos = (M * vec4(pos, 1.)).xyz;
}
]]>
		</program>
		<program name="fp" type="fragment">
<![CDATA[
#version 330 core
#define TWOPI 6.28318531
#define PI 3.14159265

uniform vec3 eye, ligPos, ligDir, ligColor;
uniform float ligWidth, ligHeight;
uniform int twoSided;

struct light{
	vec3 	pos; 
	vec3 	up, right, front;
	vec3 	col;
   float halfWidth, halfHeight;
   vec3 	p0, p1, p2, p3;
   vec3 	p0_P, p1_P, p2_P, p3_P, pos_P;
};

in jit_PerVertex {
	smooth vec3 nor;
	smooth vec3 pos;
} jit_in;

out vec4 col;

float saturate(float x){return clamp(x, 0., 1.);}

void getLigthParams(inout light lig, vec3 P){
			lig.col 			= ligColor;
			lig.pos 			= ligPos;
			lig.front 		= ligDir;
			lig.right 		= cross(ligDir, vec3(0., 1., 0.));
			lig.up 			= cross(lig.right, lig.front);
			lig.halfWidth 	= ligWidth*0.5;
			lig.halfHeight = ligHeight*0.5;
	vec3 	right 			= lig.right * lig.halfWidth;
	vec3 	up 				= lig.up 	* lig.halfHeight; 
   		lig.p0 			= ligPos + right + up;
   		lig.p1 			= ligPos - right + up;
   		lig.p2 			= ligPos - right - up;
   		lig.p3 			= ligPos + right - up;
   		lig.p0_P 		= lig.p0 - P;
   		lig.p1_P 		= lig.p1 - P;
   		lig.p2_P 		= lig.p2 - P;
   		lig.p3_P 		= lig.p3 - P;
   		lig.pos_P 		= lig.pos - P;
}

float rectSolidAngle(in light lig){

   vec3 		n0 = normalize(cross(lig.p0_P, lig.p1_P));
   vec3 		n1 = normalize(cross(lig.p1_P, lig.p2_P));
   vec3 		n2 = normalize(cross(lig.p2_P, lig.p3_P));
   vec3 		n3 = normalize(cross(lig.p3_P, lig.p0_P));
    
   float 	g0 = acos(dot(-n0, n1));
	float 	g1 = acos(dot(-n1, n2));
	float 	g2 = acos(dot(-n2, n3));
	float 	g3 = acos(dot(-n3, n0));
    
   return 	g0 + g1 + g2 + g3 - TWOPI;
}
vec3 rayPlaneIntersect(vec3 ro, vec3 rd, light lig)
{
   return ro + rd*(dot(lig.front, lig.pos - ro) / dot(lig.front, rd));
}
float getDif(vec3 P, vec3 N, vec3 R, in light lig){

	//mean of five point lights multiplied by the solid angle
	return 	rectSolidAngle(lig) * 0.2 * (
			saturate ( dot( normalize(lig.p0_P), N ) )+
			saturate ( dot( normalize(lig.p1_P), N ) )+
			saturate ( dot( normalize(lig.p2_P), N ) )+
			saturate ( dot( normalize(lig.p3_P), N ) )+
			saturate ( dot( normalize(lig.pos_P), N ))
			);

}
float getSpe(vec3 P, vec3 N, vec3 R, in light lig){

	//SDF of the plane
	//float	planeDist = dot(eye,lig.front) + dot(lig.pos, lig.front);
	//float posDist = length(eye - P);
	//if(posDist > planeDist){return 0.;}

    // calculate point on the rectangle surface/edge based on the ray originating from the shaded point
    vec3 	planePointCenter 	= rayPlaneIntersect(P, R, lig);
    //float  intersectionDist = length(planePointCenter - P);
    //if(posDist < intersectionDist){return 0.;}
    // project point on the plane on which the rectangle lies
    			planePointCenter -= lig.pos;
    vec2 	planePointProj 	= vec2(dot(planePointCenter, lig.right), dot(planePointCenter, lig.up));
    			planePointProj.x 	= clamp(planePointProj.x, -lig.halfWidth, lig.halfWidth);
    			planePointProj.y 	= clamp(planePointProj.y, -lig.halfHeight, lig.halfHeight);
    vec3 	L 						= lig.pos + lig.right*planePointProj.x + lig.up*planePointProj.y;  
    			L -= P; 

    vec3 	ligDir 	= normalize(L);
    float	ligDis 	= length(L);
    float 	spe 	= max(dot(ligDir, R), 0.);
    return pow(spe, 200.)* (1./(ligDis*ligDis));
    //return 	pow(spe, 20) * (smoothstep(0., 1., saturate(1. - abs((planePointProj.x/lig.halfWidth)))*4)*0.6 + 0.4)
    //					* (smoothstep(0., 1., saturate(1. - abs((planePointProj.y/lig.halfHeight)))*4)*0.6 + 0.4) * (1./(ligDis*ligDis));

}

vec3 getRectLight(in light lig, vec3 P, vec3 N, vec3 R){

	getLigthParams(lig, P);

   bool 		windingCheck = twoSided == 1 ? true : dot(lig.front, lig.pos - P) < 0.;
	float 	dif = windingCheck ? getDif(P, N, R, lig) : 0.;
	float 	spe = windingCheck ? getSpe(P, N, R, lig) : 0.;
return lig.col * spe;//mix(dif, spe, 0.5);
	//return lig.col * mix(dif, spe, 0.5);
}
void main() {
//I'm trying the Frostbite implementation of a rectangular light
//https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
//and https://www.shadertoy.com/view/wlSfW1
	vec3 	P = jit_in.pos;
	vec3 	N = normalize(jit_in.nor);
	vec3 	V = normalize(P - eye);
	vec3 	R = reflect(V, N);
			col.rgb = vec3(0.);

			light lig;
			col.rgb 	+= getRectLight(lig, P, N, R);

			col.rgb 	/= col.rgb + vec3(1.);
			col.rgb 	= pow(col.rgb, vec3(1./2.2));
			col.a 	= 1.;
}	
]]>
		</program>
	</language>
</jittershader>
