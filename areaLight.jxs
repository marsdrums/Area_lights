<jittershader name="fill-flat-quads">
	<description>Default Shader </description>
	<param name="pos" type="vec3" state="POSITION" />
	<param name="nor" type="vec3" state="NORMAL" />
	<param name="M" type="mat4" state="WORLD_MATRIX" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />
	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<language name="glsl" version="1.5">
		<bind param="pos" program="vp" />
		<bind param="nor" program="vp" />
		<bind param="M" program="vp" />
		<bind param="MVP" program="vp" />
		<bind param="eye" program="fp" />
		<program name="vp" type="vertex">
<![CDATA[
#version 330 core
uniform mat4 MVP, M;
in vec3 pos, nor;

out jit_PerVertex {
	smooth vec3 nor;
	smooth vec3 pos;
} jit_out;

void main() {	
	gl_Position = MVP * vec4(pos, 1.);	
	jit_out.nor = (M * vec4(nor, 0.)).xyz;
	jit_out.pos = (M * vec4(pos, 1.)).xyz;
}
]]>
		</program>
		<program name="fp" type="fragment">
<![CDATA[
#version 330 core
#define TWOPI 6.28318531
#define PI 3.14159265

uniform vec3 eye;

struct light{
	vec3 pos; 
	vec3 up;
	vec3 left;
	vec3 front;
    vec2 halfSize;
    float width;
    float height;
};

in jit_PerVertex {
	smooth vec3 nor;
	smooth vec3 pos;
} jit_in;

out vec4 col;

float saturate(float x){return clamp(x, 0., 1.);}

float rectSolidAngle(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3){

    vec3 v0 = p0 - p;
    vec3 v1 = p1 - p;
    vec3 v2 = p2 - p;
    vec3 v3 = p3 - p;
    
    vec3 n0 = normalize(cross(v0, v1));
    vec3 n1 = normalize(cross(v1, v2));
    vec3 n2 = normalize(cross(v2, v3));
    vec3 n3 = normalize(cross(v3, v0));
    
    float g0 = acos(dot(-n0, n1));
	float g1 = acos(dot(-n1, n2));
	float g2 = acos(dot(-n2, n3));
	float g3 = acos(dot(-n3, n0));
    
    return g0 + g1 + g2 + g3 - TWOPI;
}

void getDiff(vec3 P, vec3 N, vec3 R, in light lig, inout float dif, inout float spe){

	//if ( dot(P - lig.pos, N) < 0.){return 0.;}

	float halfWidth = lig.width * 0.5;
	float halfHeight = lig.height * 0.5;
	vec3 p0 = lig.pos + lig.left * -halfWidth + lig.up * +halfHeight ;
	vec3 p1 = lig.pos + lig.left * -halfWidth + lig.up * -halfHeight ;
	vec3 p2 = lig.pos + lig.left * +halfWidth + lig.up * -halfHeight ;
	vec3 p3 = lig.pos + lig.left * +halfWidth + lig.up * +halfHeight ;
	float solidAngle = rectSolidAngle ( P , p0 , p1 , p2 , p3 );

	dif = solidAngle * 0.2 * (
	saturate ( dot( normalize ( p0 - P ) , N ) )+
	saturate ( dot( normalize ( p1 - P ) , N ) )+
	saturate ( dot( normalize ( p2 - P ) , N ) )+
	saturate ( dot( normalize ( p3 - P ) , N ) )+
	saturate ( dot( normalize ( lig.pos - P ) , N ))
	);
	//mean of five point light multiplied by the solid angle

	spe = solidAngle * 0.2 * (
	saturate ( dot( R, normalize ( p0 - P )) )+
	saturate ( dot( R, normalize ( p1 - P )) )+
	saturate ( dot( R, normalize ( p2 - P )) )+
	saturate ( dot( R, normalize ( p3 - P )) )+
	saturate ( dot( R, normalize ( lig.pos - P )))
	);
	spe = pow(spe, 10.);
}

void main() {
//I'm trying the Frostbite implementation of a rectangular light
//https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	vec3 P = jit_in.pos;
	vec3 N = normalize(jit_in.nor);
	vec3 V = normalize(P - eye);
	vec3 R = reflect(V, N);

	light lig;
	lig.pos = vec3(0., -0.1, 0);
	lig.up = vec3(0., 1., 0.);
	lig.left = vec3(-1., 0., 0.);
	lig.width = 1;
	lig.height = 5.;

float dif, spe;
getDiff(P, N, R, lig, dif, spe);
	col.rgb = vec3(mix(dif, spe, 0.7));
	col.rgb /= col.rgb + vec3(1.);
	col.rgb = pow(col.rgb, vec3(1./2.2));

	col.a 	= 1.;
}	
]]>
		</program>
	</language>
</jittershader>
