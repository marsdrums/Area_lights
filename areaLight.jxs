<jittershader name="fill-flat-quads">
	<description>Default Shader </description>
	<param name="pos" type="vec3" state="POSITION" />
	<param name="nor" type="vec3" state="NORMAL" />
	<param name="M" type="mat4" state="WORLD_MATRIX" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />
	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<language name="glsl" version="1.5">
		<bind param="pos" program="vp" />
		<bind param="nor" program="vp" />
		<bind param="M" program="vp" />
		<bind param="MVP" program="vp" />
		<bind param="eye" program="fp" />
		<program name="vp" type="vertex">
<![CDATA[
#version 330 core
uniform mat4 MVP, M;
in vec3 pos, nor;

out jit_PerVertex {
	smooth vec3 nor;
	smooth vec3 pos;
} jit_out;

void main() {	
	gl_Position = MVP * vec4(pos, 1.);	
	jit_out.nor = (M * vec4(nor, 0.)).xyz;
	jit_out.pos = (M * vec4(pos, 1.)).xyz;
}
]]>
		</program>
		<program name="fp" type="fragment">
<![CDATA[
#version 330 core
#define TWOPI 6.28318531
#define PI 3.14159265

uniform vec3 eye;

struct light{
	vec3 pos; 
	vec3 up;
	vec3 right;
	vec3 front;
    float width, halfWidth;
    float height, halfHeight;
    vec3 p0, p1, p2, p3;
};

in jit_PerVertex {
	smooth vec3 nor;
	smooth vec3 pos;
} jit_in;

out vec4 col;

float saturate(float x){return clamp(x, 0., 1.);}

float rectSolidAngle(vec3 P, in light lig){

    vec3 	v0 = lig.p0 - P;
    vec3 	v1 = lig.p1 - P;
    vec3 	v2 = lig.p2 - P;
    vec3 	v3 = lig.p3 - P;
    
    vec3 	n0 = normalize(cross(v0, v1));
    vec3 	n1 = normalize(cross(v1, v2));
    vec3 	n2 = normalize(cross(v2, v3));
    vec3 	n3 = normalize(cross(v3, v0));
    
    float 	g0 = acos(dot(-n0, n1));
	float 	g1 = acos(dot(-n1, n2));
	float 	g2 = acos(dot(-n2, n3));
	float 	g3 = acos(dot(-n3, n0));
    
    return 	g0 + g1 + g2 + g3 - TWOPI;
}
vec3 rayPlaneIntersect(vec3 ro, vec3 rd, light lig)
{
   return ro + rd*(dot(lig.front, lig.pos - ro) / dot(lig.front, rd));
}
float getDif(vec3 P, vec3 N, vec3 R, in light lig){

	float 	solidAngle = rectSolidAngle(P, lig);

	//mean of five point light multiplied by the solid angle
	return 	solidAngle * 0.2 * (
			saturate ( dot( normalize ( lig.p0 - P ) , N ) )+
			saturate ( dot( normalize ( lig.p1 - P ) , N ) )+
			saturate ( dot( normalize ( lig.p2 - P ) , N ) )+
			saturate ( dot( normalize ( lig.p3 - P ) , N ) )+
			saturate ( dot( normalize ( lig.pos - P ) , N ))
			);

}
float getSpe(vec3 P, vec3 N, vec3 R, in light lig){

	vec3 	ro = P;
	vec3 	rd = R;

    // calculate point on the rectangle surface/edge based on the ray originating from the shaded point
    vec3 	planePointCenter 	= rayPlaneIntersect(ro, rd, lig) - lig.pos;
    // project point on the plane on which the rectangle lies
    vec2 	planePointProj 		= vec2(dot(planePointCenter, lig.right), dot(planePointCenter, lig.up));
    		planePointProj.x 	= clamp(planePointProj.x, -lig.halfWidth, lig.halfWidth);
    		planePointProj.y 	= clamp(planePointProj.y, -lig.halfHeight, lig.halfHeight);


    vec3 	L 					= lig.pos + lig.right*planePointProj.x + lig.up*planePointProj.y;  
    		L -= P; 


    //if (planePointProj.x >= -lig.halfWidth && planePointProj.x >= -lig.halfHeight && planePointProj.y <= lig.halfWidth && planePointProj.y <= lig.halfHeight){
    	vec3 	ligDir 	= normalize(L);
    	float	ligDis 	= length(L);
    	float 	spe 	= max(dot(ligDir, R), 0.);
    	return 	pow(spe, 1000) * (1./(ligDis*ligDis));
    	//return 0.;
    //}


    //return 	0.;

}

void main() {
//I'm trying the Frostbite implementation of a rectangular light
//https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
//and https://www.shadertoy.com/view/wlSfW1
	vec3 	P = jit_in.pos;
	vec3 	N = normalize(jit_in.nor);
	vec3 	V = normalize(P - eye);
	vec3 	R = reflect(V, N);

	//set ligh parameters
			light lig;
			lig.pos = vec3(0., 1., 0);
			lig.up = vec3(0., 1., 0.);
			lig.right = vec3(1., 0., 0.);
			lig.front = normalize(cross(lig.right, lig.up));
			lig.width = 2;
			lig.height = 2.;
			lig.halfWidth = lig.width * 0.5;
			lig.halfHeight = lig.height * 0.5;

    		lig.p0 = lig.pos + lig.halfWidth * lig.right + lig.halfHeight * lig.up;
    		lig.p1 = lig.pos - lig.halfWidth * lig.right + lig.halfHeight * lig.up;
    		lig.p2 = lig.pos - lig.halfWidth * lig.right - lig.halfHeight * lig.up;
    		lig.p3 = lig.pos + lig.halfWidth * lig.right - lig.halfHeight * lig.up;

    bool 	windingCheck = dot(lig.front, lig.pos - P) < 0.;
	float 	dif = windingCheck ? getDif(P, N, R, lig) : 0.;
	float 	spe = windingCheck ? getSpe(P, N, R, lig) : 0.;

			col.rgb = vec3(mix(dif, spe, 0.5));
			col.rgb /= col.rgb + vec3(1.);
			col.rgb = pow(col.rgb, vec3(1./2.2));
			col.a 	= 1.;
}	
]]>
		</program>
	</language>
</jittershader>
